try(
{
if (length(age_window) == 0) {
continue
}
indiv2 = sample(age_window, 1)
IDs = IDs[ !IDs == indiv2]
indiv2_age = sera[sera$Sample_ID == indiv2,]$Age
titer1 = as.numeric(sera[sera$Sample_ID == indiv1 , c(3:10)])
titer2 = as.numeric(sera[sera$Sample_ID == indiv2 , c(3:10)])
# Re-calculate log2 titers without dividing by 10
titer1 <- log(2^titer1*10, base = 2)
titer2 <- log(2^titer2*10, base = 2)
#If any values are at the limit of detection (i.e., originally coded as 10)
if(any(titer1 == log(10, base = 2)) | any(titer2 == log(10, base = 2))){
# For any titers coded as 10 (LOD), impute a random uniform value between 1-20
# Do this n_replicate_imputations times for this pair of people, compute mean cosine similarity
replicate(n = n_replicate_imputations,
{
# For any titers coded as 10 (LOD), impute a random uniform value between 1-20
titer1[titer1 == log(10, base = 2)] <- log(runif(n = length(titer1[titer1 == log(10, base = 2)]),
1, 20),
base = 2)
titer2[titer2 == log(10, base = 2)] <- log(runif(n = length(titer2[titer2 == log(10, base = 2)]),
1, 20),
base = 2)
tibble(cosine_sim = cosine(titer1, titer2)[1],
# Note that Spearman correlation will be NA if an individual has the same titer to all viruses
spearman_cor = cor.test(titer1, titer2, method = 'spearman')$estimate)
}, simplify = F
) %>%
bind_rows() %>%
summarise(across(everything(), mean)) -> mean_stats_across_imputations
cosine_similarity <- mean_stats_across_imputations$cosine_sim
spearman_cor <- mean_stats_across_imputations$spearman_cor
}else{
cosine_similarity <- cosine(titer1, titer2)
spearman_cor <- cor.test(titer1, titer2, method = 'spearman')$estimate
}
age = (indiv1_age + indiv2_age)/2
cosine_similarities = c(cosine_similarities, cosine_similarity)
spearman_correlations <- c(spearman_correlations, spearman_cor)
ages = c(ages, age)
},silent=T
)
}
df = data.frame(cosine_similarities, spearman_correlations, ages)
cosine_vs_age_model = lm(cosine_similarities ~ ages, data=df)
cor_vs_age_model = lm(spearman_correlations ~ ages, data=df)
cosine_predicts <- cbind(cosine_predicts,
predict(cosine_vs_age_model, newdata = data.frame(ages = xseq),
se=TRUE)$fit)
cosine_vs_age_slopes = c(cosine_vs_age_slopes, summary(cosine_vs_age_model)$coefficients[2,1])
cor_predicts <- cbind(cor_predicts,
predict(cor_vs_age_model, newdata = data.frame(ages = xseq),
se=TRUE)$fit)
print (r)
}
# For this many replicate pairings
n_replicate_pairings <- 1000
# When people have values at LOD, perform this many imputations
n_replicate_imputations <- 1
for (r in 1:n_replicate_pairings) {
cosine_similarities = c()
spearman_correlations <- c()
ages = c()
IDs = sera$Sample_ID
# Pair individuals of similar age, compute cosine similarity, Spearman correlation
for (i in 1:(length(sera$Sample_ID))/2 ){
if (length(IDs) == 0) {
break
}
indiv1 = sample(IDs, 1)
IDs = IDs[ !IDs == indiv1]
indiv1_age = sera[sera$Sample_ID == indiv1,]$Age
age_window = sera[sera$Age >= indiv1_age - 3 & sera$Age <= indiv1_age + 3, ]$Sample_ID
age_window = intersect(age_window, IDs)
try(
{
if (length(age_window) == 0) {
continue
}
indiv2 = sample(age_window, 1)
IDs = IDs[ !IDs == indiv2]
indiv2_age = sera[sera$Sample_ID == indiv2,]$Age
titer1 = as.numeric(sera[sera$Sample_ID == indiv1 , c(3:10)])
titer2 = as.numeric(sera[sera$Sample_ID == indiv2 , c(3:10)])
# Re-calculate log2 titers without dividing by 10
titer1 <- log(2^titer1*10, base = 2)
titer2 <- log(2^titer2*10, base = 2)
#If any values are at the limit of detection (i.e., originally coded as 10)
if(any(titer1 == log(10, base = 2)) | any(titer2 == log(10, base = 2))){
# For any titers coded as 10 (LOD), impute a random uniform value between 1-20
# Do this n_replicate_imputations times for this pair of people, compute mean cosine similarity
replicate(n = n_replicate_imputations,
{
# For any titers coded as 10 (LOD), impute a random uniform value between 1-20
titer1[titer1 == log(10, base = 2)] <- log(runif(n = length(titer1[titer1 == log(10, base = 2)]),
1, 20),
base = 2)
titer2[titer2 == log(10, base = 2)] <- log(runif(n = length(titer2[titer2 == log(10, base = 2)]),
1, 20),
base = 2)
tibble(cosine_sim = cosine(titer1, titer2)[1],
# Note that Spearman correlation will be NA if an individual has the same titer to all viruses
spearman_cor = cor.test(titer1, titer2, method = 'spearman')$estimate)
}, simplify = F
) %>%
bind_rows() %>%
summarise(across(everything(), mean)) -> mean_stats_across_imputations
cosine_similarity <- mean_stats_across_imputations$cosine_sim
spearman_cor <- mean_stats_across_imputations$spearman_cor
}else{
cosine_similarity <- cosine(titer1, titer2)
spearman_cor <- cor.test(titer1, titer2, method = 'spearman')$estimate
}
age = (indiv1_age + indiv2_age)/2
cosine_similarities = c(cosine_similarities, cosine_similarity)
spearman_correlations <- c(spearman_correlations, spearman_cor)
ages = c(ages, age)
},silent=T
)
}
df = data.frame(cosine_similarities, spearman_correlations, ages)
cosine_vs_age_model = lm(cosine_similarities ~ ages, data=df)
cor_vs_age_model = lm(spearman_correlations ~ ages, data=df)
cosine_predicts <- cbind(cosine_predicts,
predict(cosine_vs_age_model, newdata = data.frame(ages = xseq),
se=TRUE)$fit)
cosine_vs_age_slopes = c(cosine_vs_age_slopes, summary(cosine_vs_age_model)$coefficients[2,1])
cor_predicts <- cbind(cor_predicts,
predict(cor_vs_age_model, newdata = data.frame(ages = xseq),
se=TRUE)$fit)
print (r)
}
cosine_vs_age_slopes = sort(cosine_vs_age_slopes)
cosine_vs_age_slopes = sort(cosine_vs_age_slopes)
quantile(cosine_vs_age_slopes, c(0.025, 0.975))
#mean of splines from randomized data
cosine.lm.MEAN = data.frame(xseq, rowMeans(cosine_predicts[,c(2:n_replicate_pairings +1)]))
colnames(cosine.lm.MEAN) = c("x", "y")
#CI of splines from randomized data
cosine_predicts_sorted = t(apply(cosine_predicts,1,sort))
cosine.lm.CI = data.frame(xseq, cosine_predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
cosine_predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
colnames(cosine.lm.CI) = c("x", "ci1", "ci2")
p_one = ggplot(df, aes(x=ages, y=cosine_similarities)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
p_one
p_lm_1000 = ggplot() +
geom_ribbon(data = cosine.lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(cosine.lm.MEAN), data=cosine.lm.MEAN, stat="identity", col="black") +
cosine_theme +
ylim(c(0,1)) + xlim(c(1,90)) +
xlab("Age (years)") + ylab("Cosine similarity")
p_lm_1000
cosine_predicts
cosine_similarities
ggplot(df, aes(x=ages, y=cosine_similarities)) +
geom_point()
p_one = ggplot(df, aes(x=ages, y=cosine_similarities)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
p_one + ylim(0,1)
p_lm_1000 = ggplot() +
geom_ribbon(data = cosine.lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(cosine.lm.MEAN), data=cosine.lm.MEAN, stat="identity", col="black") +
cosine_theme +
ylim(c(0,1)) + xlim(c(1,90)) +
xlab("Age (years)") + ylab("Cosine similarity")
p_lm_1000
cosine_predicts_sorted
ncol(cosine_predicts_sorted)
nrow(cosine_predicts_sorted)
nrow(cosine_predicts)
length(ages)
ages
xseq
x <- sample(1:7, size = 8, replace = T)
y <- sample(1:7, size = 8, replace = T)
x
y
x <- log(2^x*10, base = 2)
y <- log(2^y*10, base = 2)
x
y
2^x
2^y
sample(1:7, size = 8, replace = T)
sera
apply(sera, 1, max)
sera
max(sera[,5])
range(sera[,5])
2^9*10
2^0
2^0 *10
2^(0:9) * 10
replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
# First, estimate expected Cosine similarity of 8-dimensional vectors
# with elements uniformly drawn from discrete set of existing dilutions
null_cosine_sim <- replicate(1000000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
null_cosine_sim
# First, estimate expected Cosine similarity of 8-dimensional vectors
# with elements uniformly drawn from discrete set of existing dilutions
null_cosine_sim <- replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
x
y
log(x, base = 2)
log(y, base = 2)
# First, estimate expected Cosine similarity of 8-dimensional vectors
# with elements uniformly drawn from discrete set of existing dilutions
null_cosine_sim <- replicate(100000,
{
x <- 2^sample(0:9, size = 8, replace = T)*10
y <- 2^sample(0:9, size = 8, replace = T)*10
cosine(log(x, base = 2),
log(y, base = 2))
}
) %>% mean()
xseq = seq(from=1, to=90, length=90)
cosine_vs_age_slopes = c()
cosine_predicts = data.frame(xseq)
cor_predicts = data.frame(xseq)
# For this many replicate pairings
n_replicate_pairings <- 1000
# When people have values at LOD, perform this many imputations
n_replicate_imputations <- 1
for (r in 1:n_replicate_pairings) {
cosine_similarities = c()
spearman_correlations <- c()
ages = c()
IDs = sera$Sample_ID
# Pair individuals of similar age, compute cosine similarity, Spearman correlation
for (i in 1:(length(sera$Sample_ID))/2 ){
if (length(IDs) == 0) {
break
}
indiv1 = sample(IDs, 1)
IDs = IDs[ !IDs == indiv1]
indiv1_age = sera[sera$Sample_ID == indiv1,]$Age
age_window = sera[sera$Age >= indiv1_age - 3 & sera$Age <= indiv1_age + 3, ]$Sample_ID
age_window = intersect(age_window, IDs)
try(
{
if (length(age_window) == 0) {
continue
}
indiv2 = sample(age_window, 1)
IDs = IDs[ !IDs == indiv2]
indiv2_age = sera[sera$Sample_ID == indiv2,]$Age
titer1 = as.numeric(sera[sera$Sample_ID == indiv1 , c(3:10)])
titer2 = as.numeric(sera[sera$Sample_ID == indiv2 , c(3:10)])
# Re-calculate log2 titers without dividing by 10
titer1 <- log(2^titer1*10, base = 2)
titer2 <- log(2^titer2*10, base = 2)
#If any values are at the limit of detection (i.e., originally coded as 10)
if(any(titer1 == log(10, base = 2)) | any(titer2 == log(10, base = 2))){
# For any titers coded as 10 (LOD), impute a random uniform value between 1-20
# Do this n_replicate_imputations times for this pair of people, compute mean cosine similarity
replicate(n = n_replicate_imputations,
{
# For any titers coded as 10 (LOD), impute a random uniform value between 1-20
titer1[titer1 == log(10, base = 2)] <- log(runif(n = length(titer1[titer1 == log(10, base = 2)]),
1, 20),
base = 2)
titer2[titer2 == log(10, base = 2)] <- log(runif(n = length(titer2[titer2 == log(10, base = 2)]),
1, 20),
base = 2)
tibble(cosine_sim = cosine(titer1, titer2)[1] - null_cosine_sim,
# Note that Spearman correlation will be NA if an individual has the same titer to all viruses
spearman_cor = cor.test(titer1, titer2, method = 'spearman')$estimate)
}, simplify = F
) %>%
bind_rows() %>%
summarise(across(everything(), mean)) -> mean_stats_across_imputations
cosine_similarity <- mean_stats_across_imputations$cosine_sim
spearman_cor <- mean_stats_across_imputations$spearman_cor
}else{
cosine_similarity <- cosine(titer1, titer2) - null_cosine_sim
spearman_cor <- cor.test(titer1, titer2, method = 'spearman')$estimate
}
age = (indiv1_age + indiv2_age)/2
cosine_similarities = c(cosine_similarities, cosine_similarity)
spearman_correlations <- c(spearman_correlations, spearman_cor)
ages = c(ages, age)
},silent=T
)
}
df = data.frame(cosine_similarities, spearman_correlations, ages)
cosine_vs_age_model = lm(cosine_similarities ~ ages, data=df)
cor_vs_age_model = lm(spearman_correlations ~ ages, data=df)
cosine_predicts <- cbind(cosine_predicts,
predict(cosine_vs_age_model, newdata = data.frame(ages = xseq),
se=TRUE)$fit)
cosine_vs_age_slopes = c(cosine_vs_age_slopes, summary(cosine_vs_age_model)$coefficients[2,1])
cor_predicts <- cbind(cor_predicts,
predict(cor_vs_age_model, newdata = data.frame(ages = xseq),
se=TRUE)$fit)
print (r)
}
cosine_vs_age_slopes = sort(cosine_vs_age_slopes)
quantile(cosine_vs_age_slopes, c(0.025, 0.975))
null_cosine_sim
#mean of splines from randomized data
cosine.lm.MEAN = data.frame(xseq, rowMeans(cosine_predicts[,c(2:n_replicate_pairings +1)]))
colnames(cosine.lm.MEAN) = c("x", "y")
#CI of splines from randomized data
cosine_predicts_sorted = t(apply(cosine_predicts,1,sort))
cosine.lm.CI = data.frame(xseq, cosine_predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
cosine_predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
colnames(cosine.lm.CI) = c("x", "ci1", "ci2")
p_one = ggplot(df, aes(x=ages, y=cosine_similarities)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
p_one + ylim(0,1)
p_one
ggplot(df, aes(x=ages, y=cosine_similarities/0.12)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
ggplot(df, aes(x=ages, y=cosine_similarities/0.11)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
p_lm_1000 = ggplot() +
geom_ribbon(data = cosine.lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(cosine.lm.MEAN), data=cosine.lm.MEAN, stat="identity", col="black") +
cosine_theme +
ylim(c(0,1)) + xlim(c(1,90)) +
xlab("Age (years)") + ylab("Cosine similarity")
p_lm_1000
p_lm_1000 + ylim(c(NA,NA))
ggplot() +
geom_ribbon(data = cosine.lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(cosine.lm.MEAN), data=cosine.lm.MEAN, stat="identity", col="black") +
cosine_theme
ggplot(df, aes(x=ages, y=spearman_correlations)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0)
# Generalizing previous code by KK
plot_similarity_vs_age_single_pairing <- function(ages, similarities){
p_one = ggplot(df, aes(x=ages, y=cosine_similarities)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)")
}
# Generalizing previous code by KK
plot_similarity_vs_age_single_pairing <- function(ages, similarities){
p_one = ggplot(df, aes(x=ages, y=similarities)) +
geom_point() +
geom_smooth(method = "lm", col="brown1", alpha=0) +
cosine_theme +
xlab("Age (years)")
}
plot_similarity_vs_age_single_pairing(ages = ages, similarities = cosine_similarities) +
ylab("Normalized cosine similarity")
summary(cosine_vs_age_model)
data.frame(unlist(summary(cosine_vs_age_model)$coefficients))
plot_similarity_vs_age_single_pairing(ages = ages, similarities = spearman_correlations) +
ylab("Spearman correlation")
data.frame(unlist(summary(cor_vs_age_model)$coefficients)
)
#mean of splines from randomized data
cosine.lm.MEAN = data.frame(xseq, rowMeans(cosine_predicts[,c(2:n_replicate_pairings +1)]))
colnames(cosine.lm.MEAN) = c("x", "y")
#CI of splines from randomized data
cosine_predicts_sorted = t(apply(cosine_predicts,1,sort))
cosine.lm.CI = data.frame(xseq, cosine_predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
cosine_predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
predicts <- cor_predicts
# mean of splines from randomized data
lm.MEAN = data.frame(xseq, rowMeans(predicts[,c(2:n_replicate_pairings +1)]))
colnames(lm.MEAN) = c("x", "y")
predicts_sorted = t(apply(predicts,1,sort))
# CI of splines from randomized data
lm.CI = data.frame(xseq, predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
colnames(cosine.lm.CI) = c("x", "ci1", "ci2")
ggplot() +
geom_ribbon(data = cosine.lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(cosine.lm.MEAN), data=cosine.lm.MEAN, stat="identity", col="black") +
cosine_theme +
ylim(c(0,1)) + xlim(c(1,90)) +
xlab("Age (years)") + ylab("Cosine similarity")
ggplot() +
geom_ribbon(data = cosine.lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(cosine.lm.MEAN), data=cosine.lm.MEAN, stat="identity", col="black") +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
ggplot() +
geom_ribbon(data = lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(lm.MEAN), data=lm.MEAN, stat="identity", col="black") +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
# mean of splines from randomized data
lm.MEAN = data.frame(xseq, rowMeans(predicts[,c(2:n_replicate_pairings +1)]))
colnames(lm.MEAN) = c("x", "y")
predicts_sorted = t(apply(predicts,1,sort))
# CI of splines from randomized data
lm.CI = data.frame(xseq, predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
colnames(cosine.lm.CI) = c("x", "ci1", "ci2")
ggplot() +
geom_ribbon(data = lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(lm.MEAN), data=lm.MEAN, stat="identity", col="black") +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
colnames(lm.CI) = c("x", "ci1", "ci2")
ggplot() +
geom_ribbon(data = lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(lm.MEAN), data=lm.MEAN, stat="identity", col="black") +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
plot_similarity_vs_age_replicate_pairings <- function(predicts){
# mean of splines from randomized data
lm.MEAN = data.frame(xseq, rowMeans(predicts[,c(2:n_replicate_pairings +1)]))
colnames(lm.MEAN) = c("x", "y")
predicts_sorted = t(apply(predicts,1,sort))
# CI of splines from randomized data
lm.CI = data.frame(xseq, predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
colnames(lm.CI) = c("x", "ci1", "ci2")
ggplot() +
geom_ribbon(data = lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(lm.MEAN), data=lm.MEAN, stat="identity", col="black") +
cosine_theme +
xlab("Age (years)") + ylab("Cosine similarity")
}
plot_similarity_vs_age_replicate_pairings <- function(predicts){
# mean of splines from randomized data
lm.MEAN = data.frame(xseq, rowMeans(predicts[,c(2:n_replicate_pairings +1)]))
colnames(lm.MEAN) = c("x", "y")
predicts_sorted = t(apply(predicts,1,sort))
# CI of splines from randomized data
lm.CI = data.frame(xseq, predicts_sorted[,round(n_replicate_pairings * 0.025)+1],
predicts_sorted[,round(n_replicate_pairings * 0.975)+1])
colnames(lm.CI) = c("x", "ci1", "ci2")
ggplot() +
geom_ribbon(data = lm.CI, aes(ymin = ci1, ymax = ci2, x=xseq), fill = "grey", alpha=0.5) +
geom_smooth(aes_auto(lm.MEAN), data=lm.MEAN, stat="identity", col="black") +
cosine_theme +
xlab("Age (years)")
}
plot_similarity_vs_age_replicate_pairings(predicts = cosine_predicts)
plot_similarity_vs_age_replicate_pairings(predicts = cor_predicts) +
ylab('Spearman correlation')
